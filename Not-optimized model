#Not-optimized model 

from dataclasses import dataclass
from typing import List, Tuple, Dict
import matplotlib.pyplot as plt
import matplotlib.patches as patches

# Constants
VERTICAL_TIME = 16.2 * 2  # down + up in seconds

# Horizontal travel times between pools
horizontal_times = {
    (0, 1): 4.1,
    (1, 2): 3.4,
    (2, 3): 3.4,
}
for i in range(3, 21):
    horizontal_times[(i, i + 1)] = 3.3
horizontal_times[(21, 22)] = 4.1  # exit

@dataclass
class Bath:
    index: int
    process_time: float  # soaking time
    drain_time: float    # draining time
    skip: bool           # skip bath

@dataclass
class Manipulator:
    index: int
    range_start: int
    range_end: int
    busy_until: float = 0.0

@dataclass
class Part:
    id: int
    schedule: List[Tuple[int, float, float]]  # (bath_index, in_time, out_time)

# Define baths
baths = [
    Bath(1, 120, 20, False),
    Bath(2, 160, 0, False),
    Bath(3, 220, 20, False),
    Bath(4, 0, 0, True),
    Bath(5, 60, 15, False),
    Bath(6, 60, 15, False),
    Bath(7, 480, 20, False),
    Bath(8, 0, 0, True),
    Bath(9, 60, 15, False),
    Bath(10, 0, 0, True),
    Bath(11, 60, 15, False),
    Bath(12, 90, 20, False),
    Bath(13, 330, 20, False),
    Bath(14, 75, 15, False),
    Bath(15, 75, 15, False),
    Bath(16, 90, 20, False),
    Bath(17, 75, 15, False),
    Bath(18, 220, 20, False),
    Bath(19, 90, 1, False),
    Bath(20, 90, 1, False),
    Bath(21, 90, 1, False),
]

# Define manipulators
manipulators = [
    Manipulator(1, 0, 3),
    Manipulator(2, 3, 7),
    Manipulator(3, 7, 11),
    Manipulator(4, 11, 17),
    Manipulator(5, 17, 20),
    Manipulator(6, 20, 22),
]

# Storage for manipulator usage for takt calculation
manipulator_usage: Dict[int, List[float]] = {m.index: [] for m in manipulators}

def find_manipulator(bath_index: int) -> Manipulator:
    for m in manipulators:
        if m.range_start < bath_index <= m.range_end:
            return m
    raise ValueError(f"No manipulator for bath {bath_index}")

def create_reverse_schedule(part_id: int, latest_exit_time: float) -> Part:
    time = latest_exit_time
    schedule = []
    for bath in reversed(baths):
        if bath.skip:
            continue
        total_time = bath.process_time + bath.drain_time
        out_time = time if schedule else time + horizontal_times[(21, 22)]
        in_time = out_time - total_time
        schedule.append((bath.index, in_time, out_time))
        if bath.index > 1:
            time = in_time - horizontal_times[(bath.index - 1, bath.index)] - VERTICAL_TIME
    return Part(part_id, list(reversed(schedule)))

def generate_schedules(num_parts: int) -> List[Part]:
    parts = []
    current_exit_time = 0
    for i in range(num_parts):
        while True:
            part = create_reverse_schedule(i + 1, latest_exit_time=current_exit_time)
            offset = abs(min(in_time for _, in_time, _ in part.schedule))
            adjusted_schedule = [(b, in_time + offset, out_time + offset) for b, in_time, out_time in part.schedule]
            part = Part(part.id, adjusted_schedule)

            valid = True
            for bath_index, in_time, out_time in part.schedule:
                m = find_manipulator(bath_index)
                if in_time < m.busy_until:
                    valid = False
                    break

            if valid:
                for bath_index, in_time, out_time in part.schedule:
                    m = find_manipulator(bath_index)
                    m.busy_until = out_time + VERTICAL_TIME
                    manipulator_usage[m.index].append(out_time + VERTICAL_TIME)
                parts.append(part)
                current_exit_time = max(out_time for _, _, out_time in part.schedule) + 1
                break
            else:
                current_exit_time += 10  # add delay if manipulator not available
    return parts

def print_manipulator_takts():
    print("\nManipulator takt times:")
    for index, times in manipulator_usage.items():
        if len(times) > 1:
            takts = [round(times[i + 1] - times[i], 2) for i in range(len(times) - 1)]
            avg_takt = round(sum(takts) / len(takts), 2)
            print(f"Manipulator {index}: avg takt = {avg_takt}s, takt list = {takts}")
        elif len(times) == 1:
            print(f"Manipulator {index}: only one operation")
        else:
            print(f"Manipulator {index}: no operations")

def plot_gantt(parts: List[Part]):
    fig, ax = plt.subplots(figsize=(12, 6))
    colors = ['skyblue', 'lightgreen', 'salmon', 'plum', 'khaki']

    for part in parts:
        for i, (bath_index, start, end) in enumerate(part.schedule):
            color = colors[part.id % len(colors)]
            ax.add_patch(patches.Rectangle((start, bath_index - 0.4), end - start, 0.8,
                                           edgecolor='black', facecolor=color))
            ax.text((start + end) / 2, bath_index, f"Part {part.id}",
                    ha='center', va='center', fontsize=8)

    ax.set_xlabel('Time (s)')
    ax.set_ylabel('Bath Number')
    ax.set_title('Gantt Chart of Part Schedules')
    ax.set_yticks([b.index for b in baths if not b.skip])
    ax.grid(True)
    plt.tight_layout()
    plt.show()

# Example usage
if __name__ == '__main__':
    parts = generate_schedules(3)  # Generate 3 parts with manipulator check
    for part in parts:
        print(f"\nPart {part.id} schedule:")
        for s in part.schedule:
            print(f"Bath {s[0]}: IN {s[1]:.2f}s, OUT {s[2]:.2f}s")
    print_manipulator_takts()
    plot_gantt(parts)
